{
  "BinarySearchDemo": {
    "demo_class_description": {
      "Demo Class Name": "Binary Search Demo",
      "Description": [
        "This file sets up a sorted array that we then perform binary search operations on. Binary search",
        "is achieved in an iterative process by using a while loop to iteratively split the list in half until the desired",
        " element is found."
      ]
    },
    "search_for_4": {
      "Title": "Search for 4",
      "Input Data": "[1, 4, 6, 7, 8, 9, 12, 14, 15, 16, 120, 199, 200, 344, 366, 377, 388]",
      "Description": [
        "Here we set up a binary search with a sorted array and then searching for the number 4. ",
        "Note that the array  list is sorted, we iteratively split the array in half to get closer to the element we are",
        " looking for. In this case we end up splitting the array iteratively on the first half of the list "
      ]
    },
    "search_for_388": {
      "Title": "Search for 388",
      "Input Data": "[1, 4, 6, 7, 8, 9, 12, 14, 15, 16, 120, 199, 200, 344, 366, 377, 388]",
      "Description": [
        "Here we set up a binary search with a sorted array and then searching for the number ",
        "388. Note that the array  list is sorted, we iteratively split the array in half to ",
        "get closer to the element we are looking for. In this case we end up splitting the ",
        "array iteratively on the second half of the list "
      ]
    },
    "element_not_found": {
      "Title": "Element not found",
      "Input Data": "[2, 6, 8, 15, 77, 88, 101]",
      "Description": [
        "In this demo we look for a nonexistent element, namely the number 102 which does not",
        " exist in the array we are searching in"
      ]
    }
  },
  "DirectionalBinarySearchDemo": {
    "demo_class_description": {
      "Demo Class Name": "Directional Binary Search Demo",
      "Description": [
        "This demo uses binary search to count the number of occurences of an element in a sorted list.",
        " This is accomplished by 1) finding the right most occurrence of the element to search for 2) finding the left",
        " most occurrence of the element to search for and then computing the difference in indexes."
      ]
    },
    "count_occurrences_of_15": {
      "Title": "Count Occurrences of 15",
      "Input Data": "[1, 4, 6, 7, 8, 9, 12, 14, 15, 15, 15, 15, 16, 16, 16, 16, 120, 120, 120, 199, 200, 344, 366, 377, 388]",
      "Description": [
        "This will compute the left most occurrence by running binary search and then splitting the ",
        "remaining elements to the left. It will then repeat the same method for iteratively splitting ",
        "the right side of the array. Finally it will calculate the difference between the right and ",
        "left index to get the total count"
      ]
    },
    "count_occurrences_of_120": {
      "Title": "Count Occurrences of 120",
      "Input Data": "[1, 4, 6, 7, 8, 9, 12, 14, 15, 15, 15, 15, 16, 16, 16, 16, 120, 120, 120, 199, 200, 344, 366, 377, 388]",
      "Description": [
        "This will compute the left most occurrence by running binary search and then splitting the ",
        "remaining elements to the left. It will then repeat the same method for iteratively splitting ",
        "the right side of the array. Finally it will calculate the difference between the right and ",
        "left index to get the total count"
      ]
    },
    "find_only_one_element": {
      "Title": "Find only one element",
      "Input Data": "[1, 4, 6, 7, 8, 9, 12, 14, 15, 16, 120, 199, 200, 344, 366, 377, 388]",
      "Description": [
        "Here we 3compute the left most and right most occurence of the search element but there is only ",
        "one element to be found. The algorithm will compute the differences of the left most and",
        " right most index and will find that they are the same index, giving us a result of count of 1"
      ]
    }
  },
  "LowestCommonAncestorDemo": {
    "demo_class_description": {
      "Demo Class Name": "Lowest Common Ancestor Demo",
      "Description": [
        "The lowest common ancestor coding problem is a binary search tree problem in which we take two",
        " elements in the tree and determine what ancestors they share and which one of these is the lowest in the tree,",
        " or rather at the deepest level. The way we do this is by finding the paths through the tree for element 1 and ",
        " element 2 and then finding which elements they have in common. Of these elements in common we check which one ",
        "is the deepest in the binary search tree. "
      ]
    },
    "lowest_common_ancestor_for_13_and_6": {
      "Title": "Find the lowest common ancestor of 13 and 6",
      "Input Data": "binary_search_tree1 = [15, 10, 20, 7, 12, 17, 22, 6, 9, 11, 13, 16, 18, 21, 23]",
      "Description": [
        "We look for the common ancestor between 13 and 6 which are both elemenets at the deepest levels ",
        "of the tree. \n The array reperesents a binary search tree in depth first order, in ",
        " order to move to the left we calculate index*2+1 and to move to the right we calculate  ",
        "index*2+2"
      ]
    },
    "lowest_common_ancestor_for_16_and_18": {
      "Title": "Find the lowest common ancestor of 14 and 17",
      "Input Data": "binary_search_tree1 = [15, 10, 20, 7, 12, 17, 22, 6, 9, 11, 13, 16, 18, 21, 23]",
      "Description": [
        "We look for the common ancestor between 13 and 6 which are both elemenets at the deepest levels ",
        "of the tree. \n The array reperesents a binary search tree in depth first order, in ",
        " order to move to the left we calculate index*2+1 and to move to the right we calculate  ",
        "index*2+2"
      ]
    },
    "lowest_common_ancestor_for_6_and_23": {
      "Title": "Find the lowest common ancestor of 6 and 23",
      "Input Data": "binary_search_tree1 = [15, 10, 20, 7, 12, 17, 22, 6, 9, 11, 13, 16, 18, 21, 23]",
      "Description": [
        "We look for the common ancestor between 13 and 6 which are both elemenets at the deepest levels ",
        "of the tree. \n The array reperesents a binary search tree in depth first order, in ",
        " order to move to the left we calculate index*2+1 and to move to the right we calculate  ",
        "index*2+2"
      ]
    }
  },
  "BinarySearchTreeDemo": {
    "demo_class_description": {
      "Demo Class Name": "BinarySearchTreeDemo",
      "Description": [
        "This file implements a binary search tree comprised of node objects. Each node object has left right and value ",
        "propereties. To construct a binary search tree we start with the root node, and then set a left pointer to a ",
        "node with a value less than the root. We do the same thing for the right and set a pointer to the a right node ",
        "with a value greater than the root. \n This file implements a binary search tree and the ability to add or ",
        "delete a node. Additionally there are methods to check whether the left and right sides of the tree are ",
        "organized properly according to the definition of a binary search tree. Finally there is a method to check ",
        "whether the entire tree is a valid binary search tree by recursively calling itself on the left and right sides ",
        "of the tree. "
      ]
    },
    "valid_bst_checks": {
      "Title": "Checks to Verify that This is a Valid BST",
      "Input Data": "See output of print tree",
      "Description": [
        "This will check to see that all nodes to the left are less than their parents and that all ndoes ",
        " to the right are greater than their parents. If any of these checks fail then the function will return False"
      ]
    },
    "delete_10_node": {
      "Title": "Delete the 10 node from the binary search tree",
      "Input Data": "See output of print tree",
      "Description": [
        "This will delete the 10 node from the binary search tree, which will trigger a rotate of some of ",
        "surrounding nodes"
      ]
    },
    "delete_root_node": {
      "Title": "Delete the root node from the binary search tree",
      "Input Data": "See output of print tree",
      "Description": [
        "This will delete the root node from the tree which will trigger rotate as well causing one of ",
        "one of the child nodes to become the root node of the tree"
      ]
    },
    "delete_root_node_twice": {
      "Title": "Delete the root node and then delete the new root node again",
      "Input Data": "See output of print tree",
      "Description": [
        "This will delete the root node from the tree causing a rotate and new root, and then repeat the action",
        "causing another rotate and another root to take place"
      ]
    }
  },
  "BreadthFirstTraversalDemo": {
    "demo_class_description": {
      "Demo Class Name": "Breadth First Traversal Demo",
      "Description": [
        "Breadth First traversal of a binary search tree is when you print all of the elements at each level before moving on",
        "to the next. In this way we end up printing across the tree from left to right at each level. One way to ",
        "accomplish this is to use a stack to iteratively append the root element, its left and right child and then do ",
        "the same for the left and right nodes. In this demo we demonstrate breadth first traversal using an array of ",
        "elements ordered to simulate a binary search tree and an actuial binary search tree with the nodes connected ",
        "to each other. "
      ]
    },
    "breadth_first_traversal_through_elements": {
      "Title": "Do a breadth first traversal through an array of elements",
      "Input Data": "binary_search_tree_elements_level_order = [14, 10, 18, 4, 12, 16, 20, 3, 5, 11, 13, 15, 17, 19, 22]",
      "Description": ["Here we do a depth first traversal by looking at the array as a binary search tree. To get the left",
      " child of an element we do the calculation left=index*2+1 and to find the right we do the calculation right=index*2+2"]
    },
    "breadth_first_traversal_through_nodes": {
      "Title": "Do a breadth first traversal through an array of elements",
      "Input Data": "See print tree output",
      "Description": ["This will perform a depth first traversal by using an array to append the nodes in depth order",
        "A nodes value is determined by looking at its value property."]
    }
  }
}